# googleSTEP Week6

> [!TIP]
> このmdは、Week5のREADMEの続きみたいなものです

## コードの説明
Week5で作ったsolver_sa_2optをinput_7で動かしたところ、なんと3日たっても実行が終了しなかった、、、
計算量の見積もりを最初にやるべきでした。。

そこで、input7の入力に耐えるために、正確性よりも実行を終わらせることを重視したコードを書いた。

### solver_simple_sa
メンターさんと相談し、とりあえず焼きなましのループの中の計算量を減らす方向性で考えた。
このコードでは、毎回のループでn回`i,j`の組み合わせを選び、これがdiffを改善するならswapする。

### solver_2opt_for7
このコードは、2optをベースとし、最初に各都市に対する基準値以下の距離の都市の配列を計算し、以降の2optではそれに基づいて２重ループを回していく。
今回基準距離である`border_dist`をうまく設定することに苦戦した。

### solver_sa_for7
上のsolver_2opt_for7と焼きなましを組み合わせた。
とにかく焼きなましのループの回数を稼ぎたかったため、`border_dist`の数は`200`ほどにした。k

## 現在の結果
simle_sa、2opt_for7の実行結果は以下の通りである。
なお、2opt_for7においてはinput6の結果が単純な2optよりも長くなることは自明なので、`border_dist=1000`以外は計測していない。
`mean near cities`は、各都市からの距離が`border_dist`以下の都市の数を、全都市数で割ったものである。

|solver|border_dist|input_6|input_7|run time(input_7)|mean near cities|
|:---|---:|---:|---:|---:|---:|
|simple_sa|-|3832.29|95983.28621|-|-|
|2opt_for7|1000|41459.18785|終わらず|-|-|
|2opt_for7|100|-|91157.21329|640.510349273681(s)|164.677490234375|
|2opt_for7|150|-|89163.56196|1343(s)|356.658935546875|
|2opt_for7|200|-|86866.48918|2456.840437(s)|725.1025390625|
|2opt_for7|300|-|86372.20492|4022.8323311805725(s)|1261.173828125|
|2opt_for7|400|-|84258.44429|7629.72099(s)|2056.77099609375|
|2opt_for7|500|-|83155.17095|21377.507103919983(s)|2933.651123046875|

## 考察など
当たり前だが`border_dist`を大きくすればするほど精度が高くなり、その分実行時間が伸びる。
試せていないのでなんとも言えないが、`border_dist`を500より増やすと、実行時間に精度改善具合が見合わなくなりそうである。

なお、今回、各都市に対する近い都市**数**ではなく**距離**を元にリストを作成したため、計算量の予測が難しくなってしまった。距離だと与えられたデータに精度が左右されてしまうので、近接都市数をパラメータにするほうが制御しやすいプログラムを作ることができそうだ。

